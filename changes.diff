diff --git a/__pycache__/upload.cpython-313.pyc b/__pycache__/upload.cpython-313.pyc
new file mode 100644
index 0000000..7698c0f
Binary files /dev/null and b/__pycache__/upload.cpython-313.pyc differ
diff --git a/refresh.py b/refresh.py
index 8eea065..ee40eee 100644
--- a/refresh.py
+++ b/refresh.py
@@ -10,11 +10,18 @@ from rich.console import Console
 from rich.panel import Panel
 from rich.table import Table
 from rich.prompt import Prompt
-from difflib import get_close_matches
 import argparse
+from difflib import get_close_matches
 
+# ----------------- Console -----------------
 console = Console()
 
+
+def style_panel(title, text, color="cyan"):
+    return Panel(text, title=title, style=color, expand=True)
+
+
+# ----------------- Config -----------------
 CONFIG = {
     "exclude_from_backup": ["backup"],
     "protected_files": [".env"],
@@ -23,16 +30,9 @@ CONFIG = {
     "backup_password": None,
 }
 
-REQUIRED_KEYS = [
-    "exclude_from_backup",
-    "protected_files",
-    "hooks",
-    "dry_run",
-    "backup_password",
-]
+REQUIRED_KEYS = list(CONFIG.keys())
 
 
-# ----------------- Config -----------------
 def load_config():
     cfg_file = Path("refresh.config.json")
     if cfg_file.exists():
@@ -49,11 +49,9 @@ def load_config():
 
 
 def validate_config(cfg):
-    # Missing keys
     for key in REQUIRED_KEYS:
         if key not in cfg:
             console.print(f"[ERROR] Missing config key '{key}'")
-    # Typo suggestions
     for key in cfg.keys():
         if key not in REQUIRED_KEYS:
             suggestion = get_close_matches(key, REQUIRED_KEYS, n=1)
@@ -63,31 +61,21 @@ def validate_config(cfg):
                 )
             else:
                 console.print(f"[WARN] Unknown config key '{key}'.")
-    # Password warning
-    password = cfg.get("backup_password")
-    if password and len(password) < 4:
-        console.print(
-            "[WARN] Backup password is very short; consider using a longer password."
-        )
 
 
 # ----------------- Commands -----------------
 def run_command(cmd, capture=False):
     if CONFIG.get("dry_run"):
-        console.print(f"[dry-run] {cmd}")
-        return "" if not capture else None
+        console.print(f"[DRY-RUN] {cmd}")
+        return None
     result = subprocess.run(cmd, shell=True, capture_output=True, text=True)
     if result.returncode != 0:
         console.print(f"[ERROR] Command failed: {cmd}\n{result.stderr.strip()}")
-        return None if capture else ""
-    if capture:
-        return result.stdout.strip()
-    else:
-        console.print(f"✔ {cmd}")
-        return result.stdout.strip()
+        return None
+    return result.stdout.strip() if capture else ""
 
 
-# ----------------- Git & Repo -----------------
+# ----------------- Git -----------------
 def ensure_gitignore():
     gitignore = Path(".gitignore")
     existing = gitignore.read_text().splitlines() if gitignore.exists() else []
@@ -115,13 +103,11 @@ def get_default_branch():
         for line in branch_info.splitlines():
             if "HEAD branch:" in line:
                 return line.split(":")[1].strip()
-    # Fallback: prüfe lokalen Branch
-    local_branch = run_command("git rev-parse --abbrev-ref HEAD", capture=True)
-    return local_branch if local_branch else "main"
+    return run_command("git rev-parse --abbrev-ref HEAD", capture=True) or "main"
 
 
 def refresh_repo(branch):
-    console.print(Panel(f"Updating repository on branch '{branch}'"))
+    console.print(style_panel("Repo Update", f"Updating branch '{branch}'", "magenta"))
     run_command("git fetch --all")
     run_command(f"git reset --hard origin/{branch}")
     run_command(f"git pull origin {branch}")
@@ -132,12 +118,10 @@ def repo_status():
     branch = run_command("git rev-parse --abbrev-ref HEAD", capture=True) or "?"
     latest_commit = run_command("git log -1 --pretty=%B", capture=True) or "?"
     author = run_command("git log -1 --pretty=%an", capture=True) or "?"
-    table = Table(
-        title="Repository Status", show_header=True, header_style="bold magenta"
-    )
-    table.add_column("Branch", style="cyan")
+    table = Table(title="Repository Status", header_style="bold cyan")
+    table.add_column("Branch", style="yellow")
     table.add_column("Last Commit", style="green")
-    table.add_column("Author", style="yellow")
+    table.add_column("Author", style="magenta")
     table.add_row(branch, latest_commit, author)
     console.print(table)
 
@@ -157,22 +141,17 @@ def backup_repo():
     zip_path = backup_dir / f"backup_{timestamp}.zip"
     password = CONFIG.get("backup_password")
 
-    console.print(Panel(f"Creating encrypted backup: {zip_path}"))
+    console.print(style_panel("Backup", f"Creating {zip_path}", "cyan"))
 
     if CONFIG.get("dry_run"):
-        console.print("[dry-run] Backup skipped")
+        console.print("[DRY-RUN] Backup skipped")
         return
 
     if password:
-        if len(password) < 4:
-            console.print(
-                "[WARN] Backup password is very short; consider using a longer password."
-            )
-        password_bytes = password.encode("utf-8")
         with pyzipper.AESZipFile(
             zip_path, "w", compression=pyzipper.ZIP_DEFLATED, encryption=pyzipper.WZ_AES
         ) as zf:
-            zf.setpassword(password_bytes)
+            zf.setpassword(password.encode("utf-8"))
             for item in Path(".").rglob("*"):
                 if item.is_file():
                     rel_path = str(item.relative_to(Path(".")))
@@ -188,14 +167,13 @@ def backup_repo():
                         continue
                     zf.write(item, rel_path)
 
-    # Hash generation
-    hash_file = backup_dir / f"{timestamp}.hash"
     sha256 = hashlib.sha256()
     with open(zip_path, "rb") as f:
         while chunk := f.read(8192):
             sha256.update(chunk)
+    hash_file = backup_dir / f"{timestamp}.hash"
     hash_file.write_text(sha256.hexdigest())
-    console.print(f"Backup completed: {zip_path}, hash stored in {hash_file}")
+    console.print(f"Backup completed. Hash stored in {hash_file}")
 
 
 # ----------------- Hooks -----------------
@@ -203,28 +181,22 @@ def run_hooks(phase):
     hooks = CONFIG.get("hooks", {}).get(phase, [])
     if not hooks:
         return
-    console.print(Panel(f"Running {phase} hooks"))
+    console.print(style_panel("Hooks", f"Running {phase}", "cyan"))
     for cmd in hooks:
-        if CONFIG.get("dry_run"):
-            console.print(f"[dry-run hook] {cmd}")
-        else:
-            run_command(cmd)
+        run_command(cmd)
 
 
 # ----------------- Dependencies -----------------
 def install_dependencies():
-    # Node.js
     if Path("package-lock.json").exists():
         run_command("npm ci")
     elif Path("package.json").exists():
         run_command("npm install")
-    # Python
     if Path("poetry.lock").exists():
         run_command("poetry install")
     if Path("Pipfile.lock").exists():
         run_command("pipenv install")
-    reqs = list(Path(".").glob("requirements*.txt"))
-    for req in sorted(reqs):
+    for req in sorted(Path(".").glob("requirements*.txt")):
         run_command(f"pip install -r {req}")
 
 
@@ -238,36 +210,41 @@ def interactive_branch_choice(default_branch):
     ]
     if not branch_list:
         return default_branch
-    choice = Prompt.ask(
-        "Which branch do you want to update?",
-        choices=branch_list,
-        default=default_branch,
-    )
-    return choice
+    return Prompt.ask("Which branch?", choices=branch_list, default=default_branch)
 
 
 # ----------------- Main -----------------
 if __name__ == "__main__":
     parser = argparse.ArgumentParser(description="Git Repo Refresher")
-    parser.add_argument("--no-backup", action="store_true", help="Skip creating a backup")
+    parser.add_argument("--no-backup", action="store_true", help="Skip backup")
+    parser.add_argument("--no-hooks", action="store_true", help="Skip pre/post hooks")
+    parser.add_argument("--no-deps", action="store_true", help="Skip dependencies")
+    parser.add_argument("--silent", action="store_true", help="Minimal output")
+    parser.add_argument("--dry-run", action="store_true", help="Simulate only")
     args = parser.parse_args()
 
-    console.print(Panel("Git Repo Refresher started", expand=True))
+    CONFIG["dry_run"] = args.dry_run
+
+    console.print(style_panel("🚀 Git Repo Refresher", "Starting...", "cyan"))
     load_config()
     ensure_gitignore()
     sensitive_file_check()
+
     if not args.no_backup:
         backup_repo()
     else:
-        console.print("[INFO] Skipping backup (flag --no-backup)")
+        console.print("[INFO] Skipping backup (--no-backup)")
 
     default_branch = get_default_branch()
     branch = interactive_branch_choice(default_branch)
-    run_hooks("pre_update")
+
+    if not args.no_hooks:
+        run_hooks("pre_update")
     refresh_repo(branch)
-    install_dependencies()
-    run_hooks("post_update")
+    if not args.no_deps:
+        install_dependencies()
+    if not args.no_hooks:
+        run_hooks("post_update")
+
     repo_status()
-    console.print(
-        "Repository is up-to-date, dependencies installed, backup step handled."
-    )
+    console.print("✅ Repository updated & ready")
diff --git a/run.py b/run.py
new file mode 100644
index 0000000..a1b8d13
--- /dev/null
+++ b/run.py
@@ -0,0 +1,69 @@
+import os
+import subprocess
+import argparse
+import importlib.util
+from pathlib import Path
+from rich.console import Console
+from rich.panel import Panel
+from rich.table import Table
+from rich.prompt import Prompt, Confirm
+
+console = Console()
+
+
+# ----------------- Helper -----------------
+def get_scripts(directory="."):
+    return [f for f in os.listdir(directory) if f.endswith(".py")]
+
+
+def get_flags(script_path):
+    """
+    Importiere das Skript dynamisch und lese argparse-Flags aus.
+    """
+    spec = importlib.util.spec_from_file_location("module.name", script_path)
+    module = importlib.util.module_from_spec(spec)  # pyright: ignore[type]
+    try:
+        spec.loader.exec_module(module)  # pyright: ignore[attribute]
+    except SystemExit:
+        # argparse ruft sys.exit() beim parse_args() auf
+        pass
+    parser = getattr(module, "parser", None)
+    if parser:
+        return [a.option_strings[0] for a in parser._actions if a.option_strings]
+    return []
+
+
+# ----------------- Main -----------------
+console.print(Panel("🚀 Python Script Launcher", style="bold cyan"))
+
+scripts = get_scripts()
+if not scripts:
+    console.print("[red]Keine Python-Skripte gefunden![/red]")
+    exit()
+
+# Skript auswählen
+table = Table(title="Available Scripts")
+table.add_column("Index", style="cyan")
+table.add_column("Script", style="green")
+for i, s in enumerate(scripts):
+    table.add_row(str(i), s)
+console.print(table)
+
+idx = int(
+    Prompt.ask("Select script by index", choices=[str(i) for i in range(len(scripts))])
+)
+script = scripts[idx]
+
+# Flags auslesen
+flags = get_flags(script)
+selected_flags = []
+if flags:
+    console.print(f"Available flags for {script}:")
+    for f in flags:
+        if Confirm.ask(f"Enable flag {f}?"):
+            selected_flags.append(f)
+
+# Run script
+cmd = ["python", script] + selected_flags
+console.print(Panel(f"Running: {' '.join(cmd)}", style="magenta"))
+subprocess.run(cmd)
diff --git a/upload.py b/upload.py
index fbdce29..a7f639b 100644
--- a/upload.py
+++ b/upload.py
@@ -2,53 +2,70 @@ import os
 import subprocess
 import time
 import requests
+import argparse
 from google.genai import Client
 from dotenv import load_dotenv
 from rich.console import Console
 from rich.panel import Panel
 from rich.progress import Progress, SpinnerColumn, TextColumn
+from rich.table import Table
 
-# Initialize rich console
+# ----------------- Console -----------------
 console = Console()
 
-# Load environment variables
-load_dotenv()
 
-# Gemini API key
+def style_panel(title, text, color="cyan"):
+    return Panel(text, title=title, style=color, expand=True)
+
+
+# ----------------- Config & Args -----------------
+parser = argparse.ArgumentParser(description="Auto Commit & PR Creator")
+parser.add_argument("--no-pr", action="store_true", help="Skip Pull Request creation")
+parser.add_argument("--no-labels", action="store_true", help="Skip PR labeling")
+parser.add_argument(
+    "--no-push", action="store_true", help="Do not push branch to remote"
+)
+parser.add_argument(
+    "--silent", action="store_true", help="Minimal output (no spinners)"
+)
+parser.add_argument("--dry-run", action="store_true", help="Simulate without executing")
+args = parser.parse_args()
+
+# Load env
+load_dotenv()
 api_key = os.getenv("GEMINI_API_KEY")
 if not api_key:
     console.print("[bold red]Error:[/bold red] GEMINI_API_KEY must be set in .env file")
-    raise ValueError("GEMINI_API_KEY must be set")
+    raise ValueError("Missing GEMINI_API_KEY")
 
-# GitHub repo info
 base_branch = "main"
 
 
+# ----------------- Helpers -----------------
 def run_verbose(cmd, description="", capture_output=False):
-    """Run a shell command with rich verbose output."""
-    console.print(
-        Panel(
-            f"[bold cyan]Running:[/bold cyan] {' '.join(cmd)}\n{description}",
-            style="magenta",
-        )
-    )
+    if args.dry_run:
+        console.print(f"[DRY-RUN] {description}: {' '.join(cmd)}")
+        return None
+    console.print(style_panel("Running", " ".join(cmd) + f"\n{description}", "magenta"))
     if capture_output:
         result = subprocess.run(cmd, text=True, capture_output=True)
-        if result.stdout:
-            console.print(Panel(result.stdout.strip(), style="green"))
-        if result.stderr:
-            console.print(Panel(result.stderr.strip(), style="red"))
         return result
     else:
         subprocess.run(cmd, check=True)
+        return None
 
 
 def gemini_generate(prompt, task_name):
-    """Show spinner while Gemini generates content."""
+    if args.silent:
+        response = client.models.generate_content(
+            model="gemini-2.5-flash", contents=prompt
+        )
+        return response.text.strip()
+
     console.print(f"[bold blue]{task_name} via Gemini...[/bold blue]")
     with Progress(
         SpinnerColumn(),
-        TextColumn("[progress.description]{task.description}"),
+        TextColumn("{task.description}"),
         transient=True,
         console=console,
     ) as progress:
@@ -60,28 +77,31 @@ def gemini_generate(prompt, task_name):
     return response.text.strip()
 
 
+# ----------------- Main -----------------
+console.print(style_panel("🚀 Auto Commit & PR Script", "Starting...", "cyan"))
+
 # Stage all changes
-run_verbose(["git", "add", "."], description="Staging all changes")
+run_verbose(["git", "add", "."], "Staging all changes")
 
 # Save staged diff
 diff_file = "changes.diff"
-with open(diff_file, "w") as f:
-    subprocess.run(["git", "diff", "--staged"], stdout=f, check=True)
-console.print(f"[bold yellow]Staged diff saved to {diff_file}[/bold yellow]")
-
-# Read diff
-with open(diff_file, "r") as f:
-    diff_content = f.read()
+if not args.dry_run:
+    with open(diff_file, "w") as f:
+        subprocess.run(["git", "diff", "--staged"], stdout=f, check=True)
+    with open(diff_file, "r") as f:
+        diff_content = f.read()
+else:
+    diff_content = "DRY RUN DIFF CONTENT"
 console.print(f"[dim]Diff length: {len(diff_content)} characters[/dim]")
 
 # Initialize Gemini client
 client = Client(api_key=api_key)
 
-# Detect commit type (multiple labels)
+# Detect commit type
 type_prompt = f"""
 Analyze the following code diff and determine all applicable change types.
 Possible labels: feature, fix, docs, refactor, test, chore.
-YOU MUST RETURN THE LABELS, AND ONLY THE LABES, IN A COMMA SEPERATED LIST.
+YOU MUST RETURN THE LABELS, AND ONLY THE LABELS, IN A COMMA SEPERATED LIST.
 (e.g. 'feature, docs')
 
 Diff:
@@ -91,95 +111,79 @@ labels_text = gemini_generate(type_prompt, "Detecting change types")
 labels = [label.strip().lower() for label in labels_text.split(",") if label.strip()]
 if not labels:
     labels = ["feature"]
-console.print(f"[bold green]Detected labels:[/bold green] {', '.join(labels)}")
 
 # Generate commit message
-commit_prompt = f"Generate a concise commit message for this code diff. YOU MUST RETURN JUST ONE MESSAGE; NOT A COLLECTION OFF MESSAGES. A MESSAGE CAN CONTAIN MULTIPLE SENTENCES:\n{diff_content}"
+commit_prompt = f"Generate a concise commit message for this code diff.\n{diff_content}"
 commit_message = gemini_generate(commit_prompt, "Commit message generation")
 if not commit_message:
     commit_message = "Auto commit with generated message"
-console.print(Panel(commit_message, title="Commit Message", style="green"))
 
 # Generate PR title
-pr_title_prompt = f"Generate a short, descriptive Pull Request title based on this code diff. YOU MUST RETURN ONLY  ONE  TITLE FOR APULL REQUEST, NOT A COLLECTION:\n{diff_content}"
-pr_title = gemini_generate(pr_title_prompt, "PR title generation")
-if not pr_title:
-    pr_title = commit_message
-console.print(Panel(pr_title, title="PR Title", style="yellow"))
+pr_title_prompt = (
+    f"Generate a short, descriptive Pull Request title for this diff.\n{diff_content}"
+)
+pr_title = gemini_generate(pr_title_prompt, "PR title generation") or commit_message
+
+# Show summary
+summary = Table(title="Commit Summary", header_style="bold cyan")
+summary.add_column("Labels", style="yellow")
+summary.add_column("Commit Message", style="green")
+summary.add_column("PR Title", style="magenta")
+summary.add_row(", ".join(labels), commit_message, pr_title)
+console.print(summary)
 
 # Create branch
 branch_name = f"{labels[0]}/auto-update-{int(time.time())}"
-run_verbose(
-    ["git", "checkout", "-b", branch_name],
-    description=f"Creating branch: {branch_name}",
-)
+run_verbose(["git", "checkout", "-b", branch_name], f"Creating branch {branch_name}")
 
-# Commit changes
-run_verbose(["git", "commit", "-m", commit_message], description="Committing changes")
+# Commit
+run_verbose(["git", "commit", "-m", commit_message], "Committing changes")
 
-# Push branch
-run_verbose(
-    ["git", "push", "origin", branch_name], description="Pushing Branch to remote"
-)
-# GitHub API info
-repo = os.getenv("GITHUB_REPO", "ProjectSaveGH/NoteManager")
-token = os.getenv("GITHUB_TOKEN")
-if not token:
-    console.print("[bold red]Error:[/bold red] GITHUB_TOKEN must be set")
-    raise ValueError("GITHUB_TOKEN not set")
-
-headers = {"Authorization": f"token {token}"}
-
-# Create Pull Request via API
-url_create_pr = f"https://api.github.com/repos/{repo}/pulls"
-payload = {
-    "title": pr_title,
-    "head": branch_name,
-    "base": base_branch,
-    "body": f"Commit Message:\n{commit_message}\n\nThis PR was generated automatically using Gemini.",
-}
-response = requests.post(url_create_pr, json=payload, headers=headers)
-
-if response.status_code == 201:
-    pr_number = response.json()["number"]
-    console.print(f"[bold green]✅ Pull Request created: #{pr_number}[/bold green]")
+# Push
+if not args.no_push:
+    run_verbose(["git", "push", "origin", branch_name], "Pushing branch to remote")
 else:
-    console.print(
-        f"[bold red]❌ Failed to create PR:[/bold red] {response.status_code} {response.text}"
-    )
-    pr_number = None
-
-# Add labels if PR creation succeeded
-if pr_number:
-    url_labels = f"https://api.github.com/repos/{repo}/issues/{pr_number}/labels"
-    payload_labels = {"labels": labels}
-    resp_labels = requests.post(url_labels, json=payload_labels, headers=headers)
-    if resp_labels.status_code == 200:
-        console.print(
-            f"[bold green]✅ Labels added to PR #{pr_number}:[/bold green] {', '.join(labels)}"
-        )
+    console.print("[INFO] Skipping push (--no-push)")
+
+# Create PR
+if not args.no_pr:
+    repo = os.getenv("GITHUB_REPO", "ProjectSaveGH/NoteManager")
+    token = os.getenv("GITHUB_TOKEN")
+    if not token:
+        raise ValueError("GITHUB_TOKEN not set")
+
+    headers = {"Authorization": f"token {token}"}
+    url_create_pr = f"https://api.github.com/repos/{repo}/pulls"
+    payload = {
+        "title": pr_title,
+        "head": branch_name,
+        "base": base_branch,
+        "body": f"Commit Message:\n{commit_message}\n\nGenerated automatically.",
+    }
+    if not args.dry_run:
+        response = requests.post(url_create_pr, json=payload, headers=headers)
+        if response.status_code == 201:
+            pr_number = response.json()["number"]
+            console.print(
+                style_panel("✅ PR Created", f"Pull Request #{pr_number}", "green")
+            )
+            if not args.no_labels:
+                url_labels = (
+                    f"https://api.github.com/repos/{repo}/issues/{pr_number}/labels"
+                )
+                payload_labels = {"labels": labels}
+                resp_labels = requests.post(
+                    url_labels, json=payload_labels, headers=headers
+                )
+                if resp_labels.status_code == 200:
+                    console.print(f"✅ Labels added: {', '.join(labels)}")
+                else:
+                    console.print(f"❌ Failed to add labels: {resp_labels.text}")
     else:
-        console.print(
-            f"[bold red]❌ Failed to add labels:[/bold red] {resp_labels.status_code} {resp_labels.text}"
-        )
+        console.print("[DRY-RUN] PR creation skipped")
+else:
+    console.print("[INFO] Skipping PR (--no-pr)")
 
-# Optional: reset local main to match remote (opt-in)
-if os.getenv("RESET_LOCAL_MAIN", "0") == "1":
-    run_verbose(
-        ["git", "fetch", "origin", "--prune"],
-        description="Sync with origin before resetting local main",
-    )
-    run_verbose(
-        ["git", "checkout", "-B", "main", "origin/main"],
-        description="Reset local main to match origin/main",
-    )
-    run_verbose(
-        ["git", "pull"],
-        description="Trying to pull changes, if previous step did not work",
-    )
-# Clean up
+# Cleanup
 if os.path.exists(diff_file):
     os.remove(diff_file)
-    console.print(
-        f"[bold magenta]Temporary diff file {diff_file} removed[/bold magenta]"
-    )
